Nidhi Hegde

Source Files List:
header.h
purenc.c
purdec.c
makefile.md 

Overview
Created a file encryption/decryption/transmission suite similar to the UNIX scp utility, using gcrypt
libraries provided by the Linux operating system. It has 2 modes: local and network

In local mode(-l option), file provided as a parameter to purenc code is encrypted and stored locally - in the same path where source file is present. The encrypted file is stored in the following format : file_name.pur
For decryption, filename.pur must be passed as the parameter.  If a file, being decrypted, has the same name as the one that would be generated by the decryption routine, then it throws error.

Command to encrypt file:
    ./purenc file_name -l

Command to decrypt file:
    ./purdec file_name.pur -l

In network mode(-d option), ip address and port number is provided to the purenc code along with input file to be encrypted. The encrypted file is then sent over the network. Assuming that decryption code is already up and running on the destination port, it would be waiting for the connection. Once it recieves the file, it decrypts it and stores the decrypted version back under original file name.
If this mode is being run in the same machine, it is strongly recommended that encryption and decryption codes are run in different folders. Since original filename would already be existing in encryption source folder.
If a file, being received and decrypted, has the same name as a file in the directory from where the decryption code is run, then it throws error.

Command to decrypt file:
    ./purdec -d portnumber

Command to encrypt file:
    ./purenc file_name -d ipaddress:portnumber


In both the modes, for the encryption and decryption suite to work properly, the passwords in both cases should be same.
A password is used to generates a derived key using the Password-Based Key Derivation Function 2 (PBKDF2) with SHA-512 as the hash function. The key is generated with the specified parameters and stored in the key buffer.

Here's a breakdown of what each argument passed to PBKDF2 does:
const char* passphrase: This is a pointer to the passphrase string used as input to the key derivation function. The passphrase can be any string of characters and is typically a user-provided password.
unsigned char* key: This is a pointer to a buffer where the derived key will be stored. The buffer must be at least 16 bytes long to accommodate the 128-bit key size used in this example.
gcry_kdf_derive: This is the function used to derive the key from the passphrase. It takes the passphrase, its length, and various other parameters as input and generates the key as output.
strlen(passphrase): This is the length of the passphrase string, which is needed as input to the key derivation function.
GCRY_KDF_PBKDF2: This specifies the key derivation function to use. In this case, it's PBKDF2.
GCRY_MD_SHA512: This specifies the hash function to use for the key derivation. In this case, it's SHA-512.
"NaCl": This is a salt value used to make the derived key unique. The salt is typically a random or pseudo-random value that is concatenated with the passphrase before being hashed.
4: This is the length of the salt value in bytes.
4096: This is the number of iterations to perform in the key derivation process. More iterations make the derived key harder to crack, but also take longer to generate.
16: This is the length of the derived key in bytes, which corresponds to a 128-bit key size.

PBKDF2 simple way to generate a cryptographic key from a passphrase using a standardized key derivation function. The derived key is then used for Encryption/Decryption (using AES256 in CBC mode) and computing MAC (HMAC running SHA512). Although using the same key in a real setup is a really bad idea, but just for the sake of simplicity, both the encryption / decryption and MAC modules use the same key. Moreover, salt and IV values are hard-coded in the program logic - this should be avoided in a real setup as well. Selection of intermediate key(s), salt and IV are usually randomized in real-world implementations.
MAC is used for authenticating encrypted file's contents. During encryption phase, MAC(encrypted content) is appended to the actual encrypted content. During decryption, MAC value is regenerated and is checked against the stored / transmitted MAC value to ensure that the encrypted content has not altered.

QUESTION:
There will be a particular decision youâ€™ll need to make for dealing with
PBKDF2. What extra input does it require and why is this used? How does your program deal with it?
ANSWER:
PBKDF2 (Password-Based Key Derivation Function 2) requires a salt value as extra input, which is used to increase the randomness and unpredictability of the derived key. The salt value is typically a randomly generated or user-provided value that is concatenated with the passphrase before being hashed. It basically helps to defend against attacks such as pre-computed dictionary attacks or rainbow table attacks, which are designed to quickly crack weak passwords or passphrases by searching through a precomputed list of hashes. In the generateKey function described above, the salt value is specified as "NaCl" and has a length of 4 bytes. This is a relatively weak salt value, as it is short and predictable, and could be improved by using a longer, more random salt value. To improve the security of the derived key, we could modify the generateKey function to accept a salt value as an additional input parameter from the user.


